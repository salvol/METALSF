# For compatibility with Python2 #
from __future__ import print_function, division, absolute_import
##################################
from . import __version__
import numpy as np
from spekpy.DataTables import MuData, MuEnAirData
from scipy import integrate, optimize, interpolate
import spekpy.SpekConstants as Const
from spekpy.IO import write_json_to_disk, full_file
from spekpy.DataTables import get_atomic_weight_data
from collections import OrderedDict as ord_dct
import re
import warnings
from copy import deepcopy


def load_mu_data(mu_data_source):
    """
    A function to load mu and muen_air data

    :param str mu_data_source: Either 'nist' or 'pene' as the argument argument
    :return functions mu_data, muen_air: Functions to get the relevant mu and 
        muen_air data
    """
    # Check to make sure that the mu_data_source is either 'nist' or 'pene'
    if mu_data_source in ('nist', 'pene'): 
        mu_data_ = mu_data_source + '_mu' + Const.extension_data_file
        muen_air_ = mu_data_source + '_muen_air' + Const.extension_data_file
    else:
        raise Exception(mu_data_source + 
                        ' is not recognized as a mu_data_source!')

    mu_data = MuData(mu_data_)
    muen_air_data = MuEnAirData(muen_air_)
    return mu_data, muen_air_data

def remove_filtration_idx(filtration_list, mut_array, idx):
    """
    A function to remove a specific filtration using the filter's index in the
    list of filters in the spekpy state

    :param list filtration_list: A list of tuples of the filtration
    :param array mut_array: An array with mu * t values for each filtration
    :param int idx: The index of the filtration to be removed
    :return list, array filtration_list, mut_array: The updated list of filters
        and mut_array
    """
    del filtration_list[idx]
    del mut_array[idx]
    return filtration_list, mut_array

def change_filtration(spekpy_obj, filter_material, filter_thickness):
    """
    A function to change the filtration that is used to filter the spectra 
    generated by spekpy

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param str filter_material: The name of the material that is used to filter
        the spectrum
    :param float filter_thickness: The thickness of the filter that is used to
        filter the spectrum
    :return:
    """
    # List of current filtration formatted as a list of (matl, t)
    filter_list = spekpy_obj.state.filtration.filters
    # Array of the attenuation coefficients (mu) multiplied with the filter thickness t
    mut_array = spekpy_obj.state.filtration.mut_fil  

    if not filter_list:  # Initial filtration
        filter_list.append((filter_material, filter_thickness))
        mut_array.append(spekpy_obj.mu_data.get_mu_t(filter_material, 
                                    spekpy_obj.model.k, filter_thickness))
    else:
        # Check if material for the added filtration has previously been used
        for filter_idx, filter_material_in_list in enumerate(filter_list):
            if filter_material == filter_material_in_list[0]:
                filter_present = True
                filter_present_idx = filter_idx
                break
            else:
                filter_present = False

        # If the material for the added filtration exists, calculate the new 
        # ... thickness (old + added) of the filter material and remove the 
        # ... filter material temporarily from filter_list and mut_array. 
        # ... Append the filtration at the end to the filter_list and mut_array
        # ... using the new filter thickness.
        if filter_present:
            new_filter_thickness = filter_list[filter_present_idx][1] + \
                filter_thickness
            filter_list, mut_array = remove_filtration_idx(filter_list, 
                                                mut_array, filter_present_idx)
            filter_list.append((filter_material, new_filter_thickness))
            mut_array.append(spekpy_obj.mu_data.get_mu_t(filter_material, 
                                    spekpy_obj.model.k, new_filter_thickness))
        else:
            filter_list.append((filter_material, filter_thickness))
            mut_array.append(spekpy_obj.mu_data.get_mu_t(filter_material,
                                        spekpy_obj.model.k, filter_thickness))

    # Update the spekpy object
    spekpy_obj.state.filtration.filters = filter_list
    spekpy_obj.state.filtration.mut_fil = mut_array
    
    return spekpy_obj


def generate_spectrum(spectrum_parameters, model_parameters, 
                      external_spectrum_parameters, model, filtration):
        """
        A function to generate a spectrum from the current spekpy state

        :param dict spectrum_parameters: Ordered dictionary of spectrum 
            parameters
        :param dict model_parameters: Ordered dictionary of model parameters
        :param dict external_spectrum_parameters: Ordered dictionary of 
            external spectrum parameters
        :param SpekModel model: Instance of the SpekModel class
        :param FiltrationDef filtration: Instance of the FiltrationDef class
        :return array spk: The photon spectrum [Photons cm^-2 keV^-1] in bins 
            of width dk
        """
        
        if model_parameters.physics == 'spekpy-v1' \
            or model_parameters.physics == 'spekcalc':
            integrator = integrate.simps
        else:
            integrator = integrate.trapz
            
        # Positional parameters
        
        # lateral position in field (heel effect axis) [cm]
        x = spectrum_parameters.x
        # lateral position in field (other axis) [cm]
        y = spectrum_parameters.y  
        # distance from source [cm]
        z = spectrum_parameters.z
        # Converts per solid angle to fluence (per cm2)
        dscale = 1.0 / (x ** 2 + y ** 2 + z ** 2)
        # tube current [mAs]
        mas = spectrum_parameters.mas 
        number_of_incident_electrons_per_mAs = Const.conversion_A2mA \
            / Const.electron_charge
        # correction for obliquity of rays through filter [bool]
        oblique = spectrum_parameters.obli 
        # include contribution from bremsstrahlung [bool]
        brem = spectrum_parameters.brem
        # include contribution from characteristic emission [bool]
        char = spectrum_parameters.char 
        t = model.t
        t_char = model.t_char
        if spectrum_parameters.ref_kerma is None \
            and spectrum_parameters.ref_flu is None:
            norm = 1.0
        else:
            norm = model.norm
        bet = np.arctan(y / z)  # Direction cosine angle in y-dir
        alp = np.arctan(x / z) # Direction cosine angle in x-dir

        if alp < np.pi / 2 and bet < np.pi / 2:
            # Ratio of filter path-length to filter thickness
            if oblique:
                fo = np.sqrt(1.0 + np.tan(alp) ** 2 + np.tan(bet) ** 2) 
            else:
                fo = 1.0
            # Attenuation by added filtration
            if filtration.mut_fil:
                mut_fil_tot = sum(filtration.mut_fil)
                fext = np.squeeze(np.exp(-mut_fil_tot[:, None] * fo))  
            else:
                fext = 1.0

            if model.anode_self_filtration is not None:
                # anode angle [degrees]
                th = model_parameters.th 
                # Anode take-off angle
                alpp = np.pi / 2 - th * np.pi / 180 - alp
                # Ratio of escape path to depth in target
                ft = np.sqrt(1.0 + np.tan(bet) ** 2 + np.tan(alpp) ** 2)
                # Self filtration by target
                fint = np.exp(-model.anode_self_filtration[:, :] 
                              * ft) 
                fint_char = np.exp(-model.anode_self_filtration_char[:, :] 
                                   * ft) 
                spk = norm * number_of_incident_electrons_per_mAs * mas \
                    * dscale * fext * \
                    ( integrator(model.brem_kt * fint, axis=1, x=t) 
                     * float(brem) +
                    integrator(model.char_kt * fint_char, axis=1, x=t_char)
                     * float(char) )
            else: # Intrinsic filtration added in SpekAniso for physics model
                spk= norm * number_of_incident_electrons_per_mAs * mas \
                    * dscale * fext * \
                    ( model.brem_k * float(brem) + model.char_k * float(char) )

        else:
            spk = np.zeros(np.size(model.k))
        return spk


def calculate_air_kerma_from_spectrum(spekpy_obj, calc_params, 
                                      mas_normalized_air_kerma):
    """
    A method to get the air Kerma of the spectrum at a point specified in the
    state of the spectrum

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param bool mas_normalized_air_kerma: A boolean indicating if the air Kerma
        should be mAs normalized
    :return float air_kerma: Calculated air Kerma for the parameters in the 
        spekpy object [uGy mAs^-1] or [uGy]
    """  
    # Energy bins of spectrum [keV]
    k = spekpy_obj.model.k
    # Bin width of spectrum [keV]
    dk = spekpy_obj.model.k[1]-spekpy_obj.model.k[0] 
    # Photon energy spectrum [keV]
    spk = generate_spectrum(calc_params, spekpy_obj.state.model_parameters,
                            spekpy_obj.state.external_spectrum,
                            spekpy_obj.model, spekpy_obj.state.filtration)
    # Tube load [mAs]
    mas = spekpy_obj.state.spectrum_parameters.mas  
    # Muen differential in energy [cm^2 g^-1]
    muen_air = spekpy_obj.muen_air_data.get_muen_over_rho_air(k)  

    with np.errstate(over='ignore', under='ignore'):
        # Convert spekpy values to units for air_kerma calculations
        muen_air_ = Const.conversion_per_g2per_kg * muen_air  # [cm^2 kg^-1]

        if mas_normalized_air_kerma:
            mas_ = 1.0 / mas
        elif not mas_normalized_air_kerma:
            mas_ = 1.0 
        else:
            raise Exception(
                'Did not recognize the keyword mas_normalized_air_kerma')

        air_kerma = Const.conversion_keV2J * Const.conversion_Gy2uGy * \
            np.sum(k * spk * mas_ * muen_air_)*dk

    return air_kerma


def make_cost_function_fraction(spekpy_obj, calc_params, filter_material, 
                                fractional_value):
    """
    A function to create a cost function that can be used to find the filter 
    thickness of a specific material to reach a
    specified fraction of air kerma

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: A specified filter material
    :param float fractional_value: A fraction of air Kerma that is desired
    :return cost_function_fraction: The cost function that is used to find the
        required thickness of a specified material needed to reach a specified
        fraction of air kerma
    """   
    # free_parameter represents a thickness of filtration
    def cost_function_fraction(free_parameter):  
        warnings.filterwarnings("ignore")
        # Store the initial filtration
        state_filtration_original = deepcopy(spekpy_obj.state.filtration)
        d0 = calculate_air_kerma_from_spectrum(spekpy_obj, calc_params, 
                                               mas_normalized_air_kerma=False)
        # Filter spectrum with a thickness of free_parameter
        change_filtration(spekpy_obj, filter_material, free_parameter)
        d = calculate_air_kerma_from_spectrum(spekpy_obj, calc_params, 
                                              mas_normalized_air_kerma=False)
        # Remove the filtration of thickness free_parameter
        spekpy_obj.state.filtration = state_filtration_original
        val = (fractional_value - d / d0) ** 2
        return val

    return cost_function_fraction


def make_cost_function_hvl(spekpy_obj, calc_params, filter_material, 
                           hvl_material, hvl_value):
    """
    A function to create a cost function that can be used to find the filter 
    thickness of a specific material to reach a specified hvl

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param filter_material: A specified filter material
    :param hvl_material: The material used to specify hvl
    :param hvl_value: the first hvl value required [mm of hv_material]
    :return: const_function_hvl1: The cost function that is used to find the
        required thickness of a specified material needed to reach a specified
        first hvl for a specified hvl material
    """
    
    def cost_function_hvl(free_parameter):
        warnings.filterwarnings("ignore")
        # Store the initial filtration
        state_filtration_original = deepcopy(spekpy_obj.state.filtration)
        change_filtration(spekpy_obj, filter_material, free_parameter)
        d0 = calculate_air_kerma_from_spectrum(spekpy_obj, calc_params, 
                                               mas_normalized_air_kerma=False)
        # Filter spectrum with a thickness of free_parameter
        change_filtration(spekpy_obj, hvl_material, hvl_value)
        d = calculate_air_kerma_from_spectrum(spekpy_obj, calc_params, 
                                              mas_normalized_air_kerma=False)
        # Remove the filtration of thickness free_parameter
        spekpy_obj.state.filtration = state_filtration_original
        val = (0.5 - d / d0) ** 2
        return val  
    
    return cost_function_hvl


def make_cost_function_effective_energy(spekpy_obj, calc_params, 
                                        filter_material, mu_):
    """
    A function to create a cost function that can be used to find the effective
    energy for a spectrum and a specified material

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param filter_material: A specified filter material
    :param mu_: target linear attenuation coefficient [cm^-1]
    :return:
    """
    mu_composition, rho = spekpy_obj.mu_data.get_mu_over_rho_composition(
        filter_material, spekpy_obj.model.k)
    ln_mu_filter_material = interpolate.interp1d(
        np.log(spekpy_obj.model.k), np.log(mu_composition * rho), 
        bounds_error=False)

    def cost_function_effective_energy(energy):
        return (mu_ - np.exp(ln_mu_filter_material(np.log(energy)))) ** 2

    return cost_function_effective_energy


def calculate_effective_energy_from_spectrum(spekpy_obj, calc_params, 
                                             filter_material):
    """
    A function to calculate the effective energy of a spectrum associated with
    the current spekpy state

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: The material of a specified filtration
    :return float effective_energy: The calculated effective energy [keV]
    """

    # Calculate the linear attenuation coefficient of the material using the 
    # ... first half value layer
    first_half_value_layer = minimize_for_fraction(spekpy_obj, calc_params, 
                                                   filter_material, 0.5)
    mu = 10.0 * np.log(2.0) / first_half_value_layer

    # Minimize the appropriate cost function to find the effective energy
    cost_function = make_cost_function_effective_energy(spekpy_obj, 
                                            calc_params, filter_material, mu)
    kvp = spekpy_obj.state.model_parameters.kvp

    e = optimize.minimize_scalar(cost_function, bounds=(1, kvp), 
                                 method='bounded')
    effective_energy = e.x

    return effective_energy


def minimize_for_fraction(spekpy_obj, calc_params, filter_material, 
                          fractional_value):
    """
    A function that is used to calculate the required thickness of a material 
    to reach a specified fractional air Kerma value

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: The material of a specified filtration
    :param float fractional_value: The target fractional value for air kerma
    :return float required_filter_thickness: The required thickness of filter 
        for the target drop in kerma
    """
    cost_function = make_cost_function_fraction(spekpy_obj, calc_params, 
                                            filter_material, fractional_value)
    t = optimize.minimize_scalar(cost_function, method='brent')
    required_filter_thickness = t.x
    return required_filter_thickness


def minimize_for_hvl(spekpy_obj, filter_material, hvl_material, hvl_value):
    """
    A function used to minimize a cost function to find the required amount of
    material to reach a fractional value of air Kerma

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param str filter_material: The material of a specified filtration
    :param str hvl_material The material for hvl definition
    :param float hvl_value: The target first hvl value
    :return required_filter_thickness: The required thickness of filter for 
        target hvl value
    """
    cost_function = make_cost_function_hvl(spekpy_obj, filter_material, 
                                           hvl_material, hvl_value)
    required_filter_thickness = optimize.minimize_scalar(cost_function,
                                                         method='brent')
    return required_filter_thickness


def calculate_first_half_value_layer_from_spectrum(spekpy_obj, calc_params, 
                                                   filter_material):
    """
    A function to calculate the first half value layer of a spectrum for a 
    desired material

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: The name of the desired filter material
    :return float first_half_value_layer: The calculated first half value 
        layer [mm]
    """
    first_half_value_layer = minimize_for_fraction(spekpy_obj, calc_params, 
                                                   filter_material, 0.5)
    return first_half_value_layer


def calculate_second_half_value_layer_from_spectrum(spekpy_obj, calc_params, 
                                                    filter_material):
    """
    A function to calculate the second half value layer for a desired material

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: The name of the desired filter material
    :return float second_half_value_layer: The calculated second half value 
        layer [mm]
    """
    first_half_value_layer = calculate_first_half_value_layer_from_spectrum(
        spekpy_obj, calc_params, filter_material)
    second_half_value_layer = minimize_for_fraction(spekpy_obj, calc_params, 
                            filter_material, 0.25) - first_half_value_layer
    return second_half_value_layer


def calculate_homogeneity_coefficient_from_spectrum(spekpy_obj, calc_params, 
                                                    filter_material):
    """
    A function to calculate the homogeniety coefficient from the spectrum

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: The desired material for the calculation of 
        the homogeneity coefficient
    :return float homogeneity_coefficient: The calculated homogeneity 
        coefficient
    """
    first_half_value_layer = calculate_first_half_value_layer_from_spectrum(
        spekpy_obj, calc_params, filter_material)
    second_half_value_layer = calculate_second_half_value_layer_from_spectrum(
        spekpy_obj, calc_params, filter_material)
    homogeneity_coefficient = first_half_value_layer / second_half_value_layer
    return homogeneity_coefficient


def calculate_mean_energy_from_spectrum(spekpy_obj, calc_params):
    """
    A function to calculate the mean energy (expected energy) from a spectrum
    for the current spekpy state

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :return float mean_energy: The mean energy of the spectrum
    """
    # The energies of the spectrum [keV]
    k = spekpy_obj.model.k  
    # The photons of the spectrum [Photons cm^-2 mAs^-1 keV^-1]
    spk = generate_spectrum(calc_params, spekpy_obj.state.model_parameters, 
                        spekpy_obj.state.external_spectrum, spekpy_obj.model, 
                        spekpy_obj.state.filtration)  
    mean_energy = np.sum(spk * k) / np.sum(spk)
    return mean_energy


def calculate_fluence_from_spectrum(spekpy_obj, calc_params):
    """
    Method to calculate the fluence from the current state of spekpy

    :param kwargs: Variable keyword arguments that can be used to change the 
        state of spekpy prior to fluence calculations
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :return float flu: The fluence of the spectrum [Photons cm^-2 mAs^-1]
    """
    # The photon energy spectrum [Photons cm^-2 mAs^-1 keV^-1]
    spk = generate_spectrum(calc_params, spekpy_obj.state.model_parameters,
                        spekpy_obj.state.external_spectrum, spekpy_obj.model,  
                        spekpy_obj.state.filtration) 
    # The energy bin width of the photon energy spectrum [keV]
    dk = spekpy_obj.state.model_parameters.dk  
    fluence = np.sum(spk) * dk
    return fluence


def calculate_required_filter_thickness(spekpy_obj, calc_params, 
            filter_material, hvl_material, half_value_layer, fractional_value):
    """
    A function to calculate the thickness of a specified material required to 
    reach a specific half value layer or air Kerma fraction

    :param Spek spekpy_obj: An instance of spekpy object (Spek class)
    :param dict calc_parameters: Ordered dictionary of spectrum parameters
    :param str filter_material: The name of the specified material
    :param float half_value_layer: The desired half value layer
    :param float fractional_value: The desired air Kerma fraction
    :return float required_thickness: The required thickness of the specified
        material needed to reach the desired half value layer or air Kerma 
        fraction [mm]
    """
    if not half_value_layer and not fractional_value:
        raise Exception(
            'You need to specify a half value layer or fractional value')

    if half_value_layer:
        cost_function = make_cost_function_hvl(spekpy_obj, calc_params, 
                            filter_material, hvl_material, half_value_layer)
        t = optimize.minimize_scalar(cost_function, method='golden')
        
    elif fractional_value:
        cost_function = make_cost_function_fraction(spekpy_obj, calc_params,
                                        filter_material, fractional_value)
        t = optimize.minimize_scalar(cost_function, method='golden')
    
    required_thickness = t.x
    return required_thickness


def calculate_output_arrays(k, spk, edges, addend):
    """
    A method to get the energy and spectrum arrays for the parameters in the 
    current spekpy state, but in bin-edge format (i.e. staircase or histogram 
    style)

    :param k: Array with photon energies (mid-bin)
    :param array spk: Array with photon fluences (values corresponding to k)
    :param bool edges: keyword
    :param bool addend: keyword
    :return array k_out: Array with photon energies (bin edge values)
    :return array spk_out: Array with photon fluences (values corresponding to
        k_out)
    """
    dk = k[1] - k[0]
    # If addend true add a zero fluence point to end of array
    if addend: 
        kp = np.concatenate((k,[k[-1]+dk]))
        spkp = np.concatenate((spk,[0.0]))
    else:
        kp = k
        spkp = spk
   # If edges true output arrays in staircase/bin format
    if edges:
        spk_out=np.repeat(spkp,2)
        kminus = kp - dk*0.5
        kplus = kp + dk*0.5
        kunsorted = np.concatenate((kminus,kplus))
        k_out = np.sort(kunsorted)
    else:
        spk_out = spkp
        k_out = kp
    return k_out, spk_out

class StandardResults:
    """
    A class for the handling of standard results from a spekpy instance
    """
    def __init__(self):
        self.k = None  # Array of energies in a spectrum [keV]
        self.spk = None  # Array of photons [Photons cm^-2 mAs^-1 keV^-1]
        self.kerma = None  # Air Kerma calculated from spectrum [uGy]
        self.flu = None  # Fluence of spectrum [Photons cm^-2 mAs^-1]
        self.emean = None  # Mean energy of spectrum [keV]
        self.hvl_1_al = None  # First half value layer of Al [mmAl]
        self.hvl_2_al = None  # Second half value layer of Al [mmAl]
        self.hc_al = None  # Homogeneity coefficient of Al
        self.eeff_al = None  # Effective energy of Al [keV]
        self.hvl_1_cu = None  # First half value layer of Cu [mmCu]
        self.hvl_2_cu = None  # Second half value layer of Cu [mmCu]
        self.hc_cu = None  # Homogeneity coefficient of Cu
        self.eeff_cu = None  # Effective energy of Cu [keV]

    def calculate_standard_results(self, spekpy_obj, calc_params):
        """
        A function to calculate standard results for a spectrum

        :param Spek spekpy_obj: An instance of spekpy object (Spek class)
        :param dict calc_parameters: Ordered dictionary of spectrum parameters
        :return StandardResults: A StandardResults object containing 
            calculations of the standard results
        """
        self.k = spekpy_obj.model.k
        self.spk = generate_spectrum(calc_params, 
                        spekpy_obj.state.model_parameters, 
                        spekpy_obj.state.external_spectrum, spekpy_obj.model, 
                        spekpy_obj.state.filtration)
        self.flu = calculate_fluence_from_spectrum(spekpy_obj, calc_params)
        self.kerma = calculate_air_kerma_from_spectrum(spekpy_obj, calc_params,
                                            mas_normalized_air_kerma=False)
        self.emean = calculate_mean_energy_from_spectrum(spekpy_obj, 
                                            calc_params)
        self.hvl_1_al = minimize_for_fraction(spekpy_obj, calc_params, 
                                              'Al', 0.5)
        self.hvl_2_al = minimize_for_fraction(spekpy_obj, calc_params, 
                                              'Al', 0.25) - self.hvl_1_al
        self.hc_al = self.hvl_1_al / self.hvl_2_al
        self.eeff_al = calculate_effective_energy_from_spectrum(spekpy_obj, 
                                                            calc_params, 'Al')
        self.hvl_1_cu = minimize_for_fraction(spekpy_obj, calc_params, 
                                              'Cu', 0.5)
        self.hvl_2_cu = minimize_for_fraction(spekpy_obj, calc_params, 
                                              'Cu', 0.25) - self.hvl_1_cu
        self.hc_cu = self.hvl_1_cu / self.hvl_2_cu
        self.eeff_cu = calculate_effective_energy_from_spectrum(spekpy_obj, 
                                                            calc_params, 'Cu')
        return self


def make_composition_def(material_name, material_density, 
                         weighted_element_tuple, chemical_formula,
                         composition_comment):

    """
    A function used to create material definitions for spekpy 

    The elemental composition of the material can be defined as a lists of 
    tuples of atomic numbers and mass fractions by weight, e.g., 
    weighted_element_tuple = [(1, 0.111898), (8, 0.888102)] 
    Alternatively, a chemical formula may be used, e.g., 
    chemical_formula = 'H2O'

    :param str material_name: The name of the material
    :param float density: The density of the material in g/cm^3
    :param list weighted_element_tuple: A list of tuples of the atomic number 
        and mass fractions by weight
    :param str chemical_formula: A chemical formula
    :param str composition_comment: A comment to accompany the material 
        definition 
    """

    #  Create an ordered dictionary with information about the material 
    # ... composition
    file_information = ord_dct([
        ('file_name', material_name + Const.extension_matl_composition),
        ('file_type', Const.dir_matl_usr),
        ('spekpy_version', __version__),
        ('comment', composition_comment)
    ])

    if material_density and weighted_element_tuple:
        
        composition = ord_dct([
            ('density', material_density),
            ('number_of_elements', len(weighted_element_tuple)),
            ('elements', weighted_element_tuple)
        ])

    if material_density and chemical_formula:
        atomic_weight_data = get_atomic_weight_data()  # From NIST XCOM
        parsed_chemical_formula = re.findall(r'([A-Z][a-z]*)(\d*(\.\d+)?)', 
                                        chemical_formula)  # Case sensitive
        elements = []
        weights = []
        atomic_numbers = []
        total_weight = 0
        for element in parsed_chemical_formula:
            el = element[0]
            # The number of atoms of a particular element in the chemcial formula
            numEl = element[1]  
            if numEl == '':
                # This occurs when a molecule has a single atom of an element 
                # ... (e.g., oxygen in H2O)
                numEl = 1.0
            else:
                numEl = float(numEl)
        
            element_weight = numEl*atomic_weight_data[el][1]
            elements.append(el)
            weights.append(element_weight)
            atomic_numbers.append(atomic_weight_data[el][0])
            total_weight += element_weight

        # Sort the elements by atomic number
        sorted_atomic_numbers = [atomic_number[0] for atomic_number \
                    in sorted(enumerate(atomic_numbers), key=lambda i:i[1])]
        weighted_element_tuple = [] 
        for idx in sorted_atomic_numbers:
            mass_fraction_by_weight = weights[idx]/total_weight
            weighted_element_tuple.append((atomic_numbers[idx], 
                                           mass_fraction_by_weight))

        composition = ord_dct([
                ('density', material_density),
                ('number_of_elements', len(weighted_element_tuple)),
                ('elements', weighted_element_tuple)
            ])

    # Create the material definition
    material_definition = ord_dct([
        ('file_information', file_information),
        ('composition', composition)
    ])

    # Save material definition to the disk
    file_name = full_file(Const.dir_data, Const.dir_matl_usr, 
                          material_definition['file_information']['file_name'])
    write_json_to_disk(data=material_definition, file_name=file_name, 
                       ordereddict=0)
